// Code generated by protoc-gen-connect-go. DO NOT EDIT.
//
// Source: tkd/roster/v1/offtime.proto

package rosterv1connect

import (
	context "context"
	errors "errors"
	connect_go "github.com/bufbuild/connect-go"
	v1 "github.com/tierklinik-dobersberg/apis/gen/go/tkd/roster/v1"
	http "net/http"
	strings "strings"
)

// This is a compile-time assertion to ensure that this generated file and the connect package are
// compatible. If you get a compiler error that this constant is not defined, this code was
// generated with a version of connect newer than the one compiled into your binary. You can fix the
// problem by either regenerating this code with an older version of connect or updating the connect
// version compiled into your binary.
const _ = connect_go.IsAtLeastVersion0_1_0

const (
	// OffTimeServiceName is the fully-qualified name of the OffTimeService service.
	OffTimeServiceName = "tkd.roster.v1.OffTimeService"
)

// These constants are the fully-qualified names of the RPCs defined in this package. They're
// exposed at runtime as Spec.Procedure and as the final two segments of the HTTP route.
//
// Note that these are different from the fully-qualified method names used by
// google.golang.org/protobuf/reflect/protoreflect. To convert from these constants to
// reflection-formatted method names, remove the leading slash and convert the remaining slash to a
// period.
const (
	// OffTimeServiceGetOffTimeEntryProcedure is the fully-qualified name of the OffTimeService's
	// GetOffTimeEntry RPC.
	OffTimeServiceGetOffTimeEntryProcedure = "/tkd.roster.v1.OffTimeService/GetOffTimeEntry"
	// OffTimeServiceCreateOffTimeRequestProcedure is the fully-qualified name of the OffTimeService's
	// CreateOffTimeRequest RPC.
	OffTimeServiceCreateOffTimeRequestProcedure = "/tkd.roster.v1.OffTimeService/CreateOffTimeRequest"
	// OffTimeServiceDeleteOffTimeRequestProcedure is the fully-qualified name of the OffTimeService's
	// DeleteOffTimeRequest RPC.
	OffTimeServiceDeleteOffTimeRequestProcedure = "/tkd.roster.v1.OffTimeService/DeleteOffTimeRequest"
	// OffTimeServiceFindOffTimeRequestsProcedure is the fully-qualified name of the OffTimeService's
	// FindOffTimeRequests RPC.
	OffTimeServiceFindOffTimeRequestsProcedure = "/tkd.roster.v1.OffTimeService/FindOffTimeRequests"
	// OffTimeServiceApproveOrRejectProcedure is the fully-qualified name of the OffTimeService's
	// ApproveOrReject RPC.
	OffTimeServiceApproveOrRejectProcedure = "/tkd.roster.v1.OffTimeService/ApproveOrReject"
	// OffTimeServiceAddOffTimeCostsProcedure is the fully-qualified name of the OffTimeService's
	// AddOffTimeCosts RPC.
	OffTimeServiceAddOffTimeCostsProcedure = "/tkd.roster.v1.OffTimeService/AddOffTimeCosts"
	// OffTimeServiceGetOffTimeCostsProcedure is the fully-qualified name of the OffTimeService's
	// GetOffTimeCosts RPC.
	OffTimeServiceGetOffTimeCostsProcedure = "/tkd.roster.v1.OffTimeService/GetOffTimeCosts"
)

// OffTimeServiceClient is a client for the tkd.roster.v1.OffTimeService service.
type OffTimeServiceClient interface {
	GetOffTimeEntry(context.Context, *connect_go.Request[v1.GetOffTimeEntryRequest]) (*connect_go.Response[v1.GetOffTimeEntryResponse], error)
	CreateOffTimeRequest(context.Context, *connect_go.Request[v1.CreateOffTimeRequestRequest]) (*connect_go.Response[v1.CreateOffTimeRequestResponse], error)
	DeleteOffTimeRequest(context.Context, *connect_go.Request[v1.DeleteOffTimeRequestRequest]) (*connect_go.Response[v1.DeleteOffTimeRequestResponse], error)
	FindOffTimeRequests(context.Context, *connect_go.Request[v1.FindOffTimeRequestsRequest]) (*connect_go.Response[v1.FindOffTimeRequestsResponse], error)
	ApproveOrReject(context.Context, *connect_go.Request[v1.ApproveOrRejectRequest]) (*connect_go.Response[v1.ApproveOrRejectResponse], error)
	AddOffTimeCosts(context.Context, *connect_go.Request[v1.AddOffTimeCostsRequest]) (*connect_go.Response[v1.AddOffTimeCostsResponse], error)
	GetOffTimeCosts(context.Context, *connect_go.Request[v1.GetOffTimeCostsRequest]) (*connect_go.Response[v1.GetOffTimeCostsResponse], error)
}

// NewOffTimeServiceClient constructs a client for the tkd.roster.v1.OffTimeService service. By
// default, it uses the Connect protocol with the binary Protobuf Codec, asks for gzipped responses,
// and sends uncompressed requests. To use the gRPC or gRPC-Web protocols, supply the
// connect.WithGRPC() or connect.WithGRPCWeb() options.
//
// The URL supplied here should be the base URL for the Connect or gRPC server (for example,
// http://api.acme.com or https://acme.com/grpc).
func NewOffTimeServiceClient(httpClient connect_go.HTTPClient, baseURL string, opts ...connect_go.ClientOption) OffTimeServiceClient {
	baseURL = strings.TrimRight(baseURL, "/")
	return &offTimeServiceClient{
		getOffTimeEntry: connect_go.NewClient[v1.GetOffTimeEntryRequest, v1.GetOffTimeEntryResponse](
			httpClient,
			baseURL+OffTimeServiceGetOffTimeEntryProcedure,
			opts...,
		),
		createOffTimeRequest: connect_go.NewClient[v1.CreateOffTimeRequestRequest, v1.CreateOffTimeRequestResponse](
			httpClient,
			baseURL+OffTimeServiceCreateOffTimeRequestProcedure,
			opts...,
		),
		deleteOffTimeRequest: connect_go.NewClient[v1.DeleteOffTimeRequestRequest, v1.DeleteOffTimeRequestResponse](
			httpClient,
			baseURL+OffTimeServiceDeleteOffTimeRequestProcedure,
			opts...,
		),
		findOffTimeRequests: connect_go.NewClient[v1.FindOffTimeRequestsRequest, v1.FindOffTimeRequestsResponse](
			httpClient,
			baseURL+OffTimeServiceFindOffTimeRequestsProcedure,
			opts...,
		),
		approveOrReject: connect_go.NewClient[v1.ApproveOrRejectRequest, v1.ApproveOrRejectResponse](
			httpClient,
			baseURL+OffTimeServiceApproveOrRejectProcedure,
			opts...,
		),
		addOffTimeCosts: connect_go.NewClient[v1.AddOffTimeCostsRequest, v1.AddOffTimeCostsResponse](
			httpClient,
			baseURL+OffTimeServiceAddOffTimeCostsProcedure,
			opts...,
		),
		getOffTimeCosts: connect_go.NewClient[v1.GetOffTimeCostsRequest, v1.GetOffTimeCostsResponse](
			httpClient,
			baseURL+OffTimeServiceGetOffTimeCostsProcedure,
			opts...,
		),
	}
}

// offTimeServiceClient implements OffTimeServiceClient.
type offTimeServiceClient struct {
	getOffTimeEntry      *connect_go.Client[v1.GetOffTimeEntryRequest, v1.GetOffTimeEntryResponse]
	createOffTimeRequest *connect_go.Client[v1.CreateOffTimeRequestRequest, v1.CreateOffTimeRequestResponse]
	deleteOffTimeRequest *connect_go.Client[v1.DeleteOffTimeRequestRequest, v1.DeleteOffTimeRequestResponse]
	findOffTimeRequests  *connect_go.Client[v1.FindOffTimeRequestsRequest, v1.FindOffTimeRequestsResponse]
	approveOrReject      *connect_go.Client[v1.ApproveOrRejectRequest, v1.ApproveOrRejectResponse]
	addOffTimeCosts      *connect_go.Client[v1.AddOffTimeCostsRequest, v1.AddOffTimeCostsResponse]
	getOffTimeCosts      *connect_go.Client[v1.GetOffTimeCostsRequest, v1.GetOffTimeCostsResponse]
}

// GetOffTimeEntry calls tkd.roster.v1.OffTimeService.GetOffTimeEntry.
func (c *offTimeServiceClient) GetOffTimeEntry(ctx context.Context, req *connect_go.Request[v1.GetOffTimeEntryRequest]) (*connect_go.Response[v1.GetOffTimeEntryResponse], error) {
	return c.getOffTimeEntry.CallUnary(ctx, req)
}

// CreateOffTimeRequest calls tkd.roster.v1.OffTimeService.CreateOffTimeRequest.
func (c *offTimeServiceClient) CreateOffTimeRequest(ctx context.Context, req *connect_go.Request[v1.CreateOffTimeRequestRequest]) (*connect_go.Response[v1.CreateOffTimeRequestResponse], error) {
	return c.createOffTimeRequest.CallUnary(ctx, req)
}

// DeleteOffTimeRequest calls tkd.roster.v1.OffTimeService.DeleteOffTimeRequest.
func (c *offTimeServiceClient) DeleteOffTimeRequest(ctx context.Context, req *connect_go.Request[v1.DeleteOffTimeRequestRequest]) (*connect_go.Response[v1.DeleteOffTimeRequestResponse], error) {
	return c.deleteOffTimeRequest.CallUnary(ctx, req)
}

// FindOffTimeRequests calls tkd.roster.v1.OffTimeService.FindOffTimeRequests.
func (c *offTimeServiceClient) FindOffTimeRequests(ctx context.Context, req *connect_go.Request[v1.FindOffTimeRequestsRequest]) (*connect_go.Response[v1.FindOffTimeRequestsResponse], error) {
	return c.findOffTimeRequests.CallUnary(ctx, req)
}

// ApproveOrReject calls tkd.roster.v1.OffTimeService.ApproveOrReject.
func (c *offTimeServiceClient) ApproveOrReject(ctx context.Context, req *connect_go.Request[v1.ApproveOrRejectRequest]) (*connect_go.Response[v1.ApproveOrRejectResponse], error) {
	return c.approveOrReject.CallUnary(ctx, req)
}

// AddOffTimeCosts calls tkd.roster.v1.OffTimeService.AddOffTimeCosts.
func (c *offTimeServiceClient) AddOffTimeCosts(ctx context.Context, req *connect_go.Request[v1.AddOffTimeCostsRequest]) (*connect_go.Response[v1.AddOffTimeCostsResponse], error) {
	return c.addOffTimeCosts.CallUnary(ctx, req)
}

// GetOffTimeCosts calls tkd.roster.v1.OffTimeService.GetOffTimeCosts.
func (c *offTimeServiceClient) GetOffTimeCosts(ctx context.Context, req *connect_go.Request[v1.GetOffTimeCostsRequest]) (*connect_go.Response[v1.GetOffTimeCostsResponse], error) {
	return c.getOffTimeCosts.CallUnary(ctx, req)
}

// OffTimeServiceHandler is an implementation of the tkd.roster.v1.OffTimeService service.
type OffTimeServiceHandler interface {
	GetOffTimeEntry(context.Context, *connect_go.Request[v1.GetOffTimeEntryRequest]) (*connect_go.Response[v1.GetOffTimeEntryResponse], error)
	CreateOffTimeRequest(context.Context, *connect_go.Request[v1.CreateOffTimeRequestRequest]) (*connect_go.Response[v1.CreateOffTimeRequestResponse], error)
	DeleteOffTimeRequest(context.Context, *connect_go.Request[v1.DeleteOffTimeRequestRequest]) (*connect_go.Response[v1.DeleteOffTimeRequestResponse], error)
	FindOffTimeRequests(context.Context, *connect_go.Request[v1.FindOffTimeRequestsRequest]) (*connect_go.Response[v1.FindOffTimeRequestsResponse], error)
	ApproveOrReject(context.Context, *connect_go.Request[v1.ApproveOrRejectRequest]) (*connect_go.Response[v1.ApproveOrRejectResponse], error)
	AddOffTimeCosts(context.Context, *connect_go.Request[v1.AddOffTimeCostsRequest]) (*connect_go.Response[v1.AddOffTimeCostsResponse], error)
	GetOffTimeCosts(context.Context, *connect_go.Request[v1.GetOffTimeCostsRequest]) (*connect_go.Response[v1.GetOffTimeCostsResponse], error)
}

// NewOffTimeServiceHandler builds an HTTP handler from the service implementation. It returns the
// path on which to mount the handler and the handler itself.
//
// By default, handlers support the Connect, gRPC, and gRPC-Web protocols with the binary Protobuf
// and JSON codecs. They also support gzip compression.
func NewOffTimeServiceHandler(svc OffTimeServiceHandler, opts ...connect_go.HandlerOption) (string, http.Handler) {
	offTimeServiceGetOffTimeEntryHandler := connect_go.NewUnaryHandler(
		OffTimeServiceGetOffTimeEntryProcedure,
		svc.GetOffTimeEntry,
		opts...,
	)
	offTimeServiceCreateOffTimeRequestHandler := connect_go.NewUnaryHandler(
		OffTimeServiceCreateOffTimeRequestProcedure,
		svc.CreateOffTimeRequest,
		opts...,
	)
	offTimeServiceDeleteOffTimeRequestHandler := connect_go.NewUnaryHandler(
		OffTimeServiceDeleteOffTimeRequestProcedure,
		svc.DeleteOffTimeRequest,
		opts...,
	)
	offTimeServiceFindOffTimeRequestsHandler := connect_go.NewUnaryHandler(
		OffTimeServiceFindOffTimeRequestsProcedure,
		svc.FindOffTimeRequests,
		opts...,
	)
	offTimeServiceApproveOrRejectHandler := connect_go.NewUnaryHandler(
		OffTimeServiceApproveOrRejectProcedure,
		svc.ApproveOrReject,
		opts...,
	)
	offTimeServiceAddOffTimeCostsHandler := connect_go.NewUnaryHandler(
		OffTimeServiceAddOffTimeCostsProcedure,
		svc.AddOffTimeCosts,
		opts...,
	)
	offTimeServiceGetOffTimeCostsHandler := connect_go.NewUnaryHandler(
		OffTimeServiceGetOffTimeCostsProcedure,
		svc.GetOffTimeCosts,
		opts...,
	)
	return "/tkd.roster.v1.OffTimeService/", http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		switch r.URL.Path {
		case OffTimeServiceGetOffTimeEntryProcedure:
			offTimeServiceGetOffTimeEntryHandler.ServeHTTP(w, r)
		case OffTimeServiceCreateOffTimeRequestProcedure:
			offTimeServiceCreateOffTimeRequestHandler.ServeHTTP(w, r)
		case OffTimeServiceDeleteOffTimeRequestProcedure:
			offTimeServiceDeleteOffTimeRequestHandler.ServeHTTP(w, r)
		case OffTimeServiceFindOffTimeRequestsProcedure:
			offTimeServiceFindOffTimeRequestsHandler.ServeHTTP(w, r)
		case OffTimeServiceApproveOrRejectProcedure:
			offTimeServiceApproveOrRejectHandler.ServeHTTP(w, r)
		case OffTimeServiceAddOffTimeCostsProcedure:
			offTimeServiceAddOffTimeCostsHandler.ServeHTTP(w, r)
		case OffTimeServiceGetOffTimeCostsProcedure:
			offTimeServiceGetOffTimeCostsHandler.ServeHTTP(w, r)
		default:
			http.NotFound(w, r)
		}
	})
}

// UnimplementedOffTimeServiceHandler returns CodeUnimplemented from all methods.
type UnimplementedOffTimeServiceHandler struct{}

func (UnimplementedOffTimeServiceHandler) GetOffTimeEntry(context.Context, *connect_go.Request[v1.GetOffTimeEntryRequest]) (*connect_go.Response[v1.GetOffTimeEntryResponse], error) {
	return nil, connect_go.NewError(connect_go.CodeUnimplemented, errors.New("tkd.roster.v1.OffTimeService.GetOffTimeEntry is not implemented"))
}

func (UnimplementedOffTimeServiceHandler) CreateOffTimeRequest(context.Context, *connect_go.Request[v1.CreateOffTimeRequestRequest]) (*connect_go.Response[v1.CreateOffTimeRequestResponse], error) {
	return nil, connect_go.NewError(connect_go.CodeUnimplemented, errors.New("tkd.roster.v1.OffTimeService.CreateOffTimeRequest is not implemented"))
}

func (UnimplementedOffTimeServiceHandler) DeleteOffTimeRequest(context.Context, *connect_go.Request[v1.DeleteOffTimeRequestRequest]) (*connect_go.Response[v1.DeleteOffTimeRequestResponse], error) {
	return nil, connect_go.NewError(connect_go.CodeUnimplemented, errors.New("tkd.roster.v1.OffTimeService.DeleteOffTimeRequest is not implemented"))
}

func (UnimplementedOffTimeServiceHandler) FindOffTimeRequests(context.Context, *connect_go.Request[v1.FindOffTimeRequestsRequest]) (*connect_go.Response[v1.FindOffTimeRequestsResponse], error) {
	return nil, connect_go.NewError(connect_go.CodeUnimplemented, errors.New("tkd.roster.v1.OffTimeService.FindOffTimeRequests is not implemented"))
}

func (UnimplementedOffTimeServiceHandler) ApproveOrReject(context.Context, *connect_go.Request[v1.ApproveOrRejectRequest]) (*connect_go.Response[v1.ApproveOrRejectResponse], error) {
	return nil, connect_go.NewError(connect_go.CodeUnimplemented, errors.New("tkd.roster.v1.OffTimeService.ApproveOrReject is not implemented"))
}

func (UnimplementedOffTimeServiceHandler) AddOffTimeCosts(context.Context, *connect_go.Request[v1.AddOffTimeCostsRequest]) (*connect_go.Response[v1.AddOffTimeCostsResponse], error) {
	return nil, connect_go.NewError(connect_go.CodeUnimplemented, errors.New("tkd.roster.v1.OffTimeService.AddOffTimeCosts is not implemented"))
}

func (UnimplementedOffTimeServiceHandler) GetOffTimeCosts(context.Context, *connect_go.Request[v1.GetOffTimeCostsRequest]) (*connect_go.Response[v1.GetOffTimeCostsResponse], error) {
	return nil, connect_go.NewError(connect_go.CodeUnimplemented, errors.New("tkd.roster.v1.OffTimeService.GetOffTimeCosts is not implemented"))
}
