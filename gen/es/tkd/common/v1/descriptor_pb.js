"use strict";
// @generated by protoc-gen-es v1.2.1 with parameter "target=js+ts"
// @generated from file tkd/common/v1/descriptor.proto (package tkd.common.v1, syntax proto3)
/* eslint-disable */
// @ts-nocheck
Object.defineProperty(exports, "__esModule", { value: true });
exports.PrivacyACL = exports.AuthDecorator = exports.AuthRequirement = void 0;
const protobuf_1 = require("@bufbuild/protobuf");
/**
 * @generated from enum tkd.common.v1.AuthRequirement
 */
var AuthRequirement;
(function (AuthRequirement) {
    /**
     * @generated from enum value: AUTH_REQ_UNSPECIFIED = 0;
     */
    AuthRequirement[AuthRequirement["AUTH_REQ_UNSPECIFIED"] = 0] = "AUTH_REQ_UNSPECIFIED";
    /**
     * @generated from enum value: AUTH_REQ_REQUIRED = 1;
     */
    AuthRequirement[AuthRequirement["AUTH_REQ_REQUIRED"] = 1] = "AUTH_REQ_REQUIRED";
})(AuthRequirement || (exports.AuthRequirement = AuthRequirement = {}));
// Retrieve enum metadata with: proto3.getEnumType(AuthRequirement)
protobuf_1.proto3.util.setEnumType(AuthRequirement, "tkd.common.v1.AuthRequirement", [
    { no: 0, name: "AUTH_REQ_UNSPECIFIED" },
    { no: 1, name: "AUTH_REQ_REQUIRED" },
]);
/**
 * @generated from message tkd.common.v1.AuthDecorator
 */
class AuthDecorator extends protobuf_1.Message {
    constructor(data) {
        super();
        /**
         * @generated from field: tkd.common.v1.AuthRequirement require = 1;
         */
        this.require = AuthRequirement.AUTH_REQ_UNSPECIFIED;
        /**
         * @generated from field: repeated string allowed_roles = 2;
         */
        this.allowedRoles = [];
        protobuf_1.proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
        return new AuthDecorator().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
        return new AuthDecorator().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
        return new AuthDecorator().fromJsonString(jsonString, options);
    }
    static equals(a, b) {
        return protobuf_1.proto3.util.equals(AuthDecorator, a, b);
    }
}
exports.AuthDecorator = AuthDecorator;
AuthDecorator.runtime = protobuf_1.proto3;
AuthDecorator.typeName = "tkd.common.v1.AuthDecorator";
AuthDecorator.fields = protobuf_1.proto3.util.newFieldList(() => [
    { no: 1, name: "require", kind: "enum", T: protobuf_1.proto3.getEnumType(AuthRequirement) },
    { no: 2, name: "allowed_roles", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
]);
/**
 * @generated from message tkd.common.v1.PrivacyACL
 */
class PrivacyACL extends protobuf_1.Message {
    constructor(data) {
        super();
        /**
         * The name of the owner ID field. If set, and the authenticated
         * user has the same ID, access to all fields is permitted.
         *
         * @generated from field: string owner_field_name = 2;
         */
        this.ownerFieldName = "";
        /**
         * A list of roles that have access to all fields.
         *
         * @generated from field: repeated string allowed_roles = 3;
         */
        this.allowedRoles = [];
        protobuf_1.proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
        return new PrivacyACL().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
        return new PrivacyACL().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
        return new PrivacyACL().fromJsonString(jsonString, options);
    }
    static equals(a, b) {
        return protobuf_1.proto3.util.equals(PrivacyACL, a, b);
    }
}
exports.PrivacyACL = PrivacyACL;
PrivacyACL.runtime = protobuf_1.proto3;
PrivacyACL.typeName = "tkd.common.v1.PrivacyACL";
PrivacyACL.fields = protobuf_1.proto3.util.newFieldList(() => [
    { no: 1, name: "field_mask", kind: "message", T: protobuf_1.FieldMask },
    { no: 2, name: "owner_field_name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "allowed_roles", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
]);
