// @generated by protoc-gen-es v2.0.0 with parameter "target=js+dts"
// @generated from file tkd/roster/v1/roster.proto (package tkd.roster.v1, syntax proto3)
/* eslint-disable */

import type { GenEnum, GenFile, GenMessage, GenService } from "@bufbuild/protobuf/codegenv1";
import type { Message } from "@bufbuild/protobuf";
import type { Duration, FieldMask, Timestamp } from "@bufbuild/protobuf/wkt";
import type { ConstraintViolationList } from "./constraint_pb";
import type { TimeRange } from "../../common/v1/time_range_pb";
import type { WorkShift } from "./workshift_pb";
import type { DeliveryNotification } from "../../idm/v1/notify_service_pb";

/**
 * Describes the file tkd/roster/v1/roster.proto.
 */
export declare const file_tkd_roster_v1_roster: GenFile;

/**
 * @generated from message tkd.roster.v1.RequiredShift
 */
export declare type RequiredShift = Message<"tkd.roster.v1.RequiredShift"> & {
  /**
   * From holds the time at which the shift begins.
   *
   * @generated from field: google.protobuf.Timestamp from = 1;
   */
  from?: Timestamp;

  /**
   * To holds the time at which the shift ends.
   *
   * @generated from field: google.protobuf.Timestamp to = 2;
   */
  to?: Timestamp;

  /**
   * WorkShiftID is the ID of the work-shift definition.
   *
   * @generated from field: string work_shift_id = 3;
   */
  workShiftId: string;

  /**
   * EligibleUserIds is set to a list of user ids that are eligible for this
   * work-shift.
   *
   * @generated from field: repeated string eligible_user_ids = 4;
   */
  eligibleUserIds: string[];

  /**
   * OnHoliday is set to true if the shift is on a public holiday.
   *
   * @generated from field: bool on_holiday = 5;
   */
  onHoliday: boolean;

  /**
   * OnWeekend is set to true if the shift is on a week-end day (Saturday or Sunday).
   *
   * @generated from field: bool on_weekend = 6;
   */
  onWeekend: boolean;

  /**
   * ViolationsPerUserId is a map indexed with user ids that holds a list of
   * violations and resoning of why a user is not part of RequiredShift.eligible_user_ids
   * even if the user would be eligible by WorkShift.eligible_roles.
   *
   * @generated from field: map<string, tkd.roster.v1.ConstraintViolationList> violations_per_user_id = 7;
   */
  violationsPerUserId: { [key: string]: ConstraintViolationList };

  /**
   * A unique ID to match PlannedShifts against RequiredShifts
   *
   * @generated from field: string unique_id = 8;
   */
  uniqueId: string;
};

/**
 * Describes the message tkd.roster.v1.RequiredShift.
 * Use `create(RequiredShiftSchema)` to create a new message.
 */
export declare const RequiredShiftSchema: GenMessage<RequiredShift>;

/**
 * PlannedShift is a planned work-shift in a roster.
 *
 * @generated from message tkd.roster.v1.PlannedShift
 */
export declare type PlannedShift = Message<"tkd.roster.v1.PlannedShift"> & {
  /**
   * From holds the time at which the shift begins.
   *
   * @generated from field: google.protobuf.Timestamp from = 1;
   */
  from?: Timestamp;

  /**
   * To holds the time at which the shift ends.
   *
   * @generated from field: google.protobuf.Timestamp to = 2;
   */
  to?: Timestamp;

  /**
   * AsssignedUserIds is a list of user IDs that are assigned to work
   * during the shift.
   *
   * @generated from field: repeated string assigned_user_ids = 3;
   */
  assignedUserIds: string[];

  /**
   * WorkShiftId is the ID of the work-shift definition.
   *
   * @generated from field: string work_shift_id = 4;
   */
  workShiftId: string;

  /**
   * A unique ID to match PlannedShifts against RequiredShifts.
   *
   * @generated from field: string unique_id = 5;
   */
  uniqueId: string;
};

/**
 * Describes the message tkd.roster.v1.PlannedShift.
 * Use `create(PlannedShiftSchema)` to create a new message.
 */
export declare const PlannedShiftSchema: GenMessage<PlannedShift>;

/**
 * @generated from message tkd.roster.v1.RosterType
 */
export declare type RosterType = Message<"tkd.roster.v1.RosterType"> & {
  /**
   * UniqueName is a unique name for this roster type.
   *
   * @generated from field: string unique_name = 1;
   */
  uniqueName: string;

  /**
   * A list of shift tags that are applicable to this roster type.
   *
   * @generated from field: repeated string shift_tags = 2;
   */
  shiftTags: string[];

  /**
   * A list of shift tags that are used for on-call requests.
   *
   * @generated from field: repeated string on_call_tags = 3;
   */
  onCallTags: string[];
};

/**
 * Describes the message tkd.roster.v1.RosterType.
 * Use `create(RosterTypeSchema)` to create a new message.
 */
export declare const RosterTypeSchema: GenMessage<RosterType>;

/**
 * Roster is a planned roster for a given time period.
 *
 * @generated from message tkd.roster.v1.Roster
 */
export declare type Roster = Message<"tkd.roster.v1.Roster"> & {
  /**
   * ID is a unique identifier for the roster.
   *
   * @generated from field: string id = 1;
   */
  id: string;

  /**
   * From holds the date of the first day in the roster.
   * It should follow the format YYYY-MM-DD as in 2006-01-02.
   *
   * @generated from field: string from = 2;
   */
  from: string;

  /**
   * To holds the date of the lalst day in the roster.
   * It should follow the format YYYY-MM-DD as in 2006-01-02.
   *
   * @generated from field: string to = 3;
   */
  to: string;

  /**
   * Shifts holds all planned work-shifts for the roster.
   * Implementations should sort the shifts by increasing
   * from time.
   *
   * @generated from field: repeated tkd.roster.v1.PlannedShift shifts = 4;
   */
  shifts: PlannedShift[];

  /**
   * Approved is set to true when the roster has been approved by
   * management.
   *
   * @generated from field: bool approved = 5;
   */
  approved: boolean;

  /**
   * ApprovedAt is set to the timestamp at which the roster has been
   * approved by management.
   *
   * @generated from field: google.protobuf.Timestamp approved_at = 6;
   */
  approvedAt?: Timestamp;

  /**
   * ApproverUserId is set to the ID of the management user that approved
   * the roster.
   *
   * @generated from field: string approver_user_id = 7;
   */
  approverUserId: string;

  /**
   * LastModifiedBy is set to the ID of the user that last changed the roster.
   *
   * @generated from field: string last_modified_by = 8;
   */
  lastModifiedBy: string;

  /**
   * CreatedAt is set to the timestamp at which the roster has been initially
   * created.
   *
   * @generated from field: google.protobuf.Timestamp created_at = 9;
   */
  createdAt?: Timestamp;

  /**
   * UpdatedAt is set to the timestamp at which the roster has been updated
   * last.
   *
   * @generated from field: google.protobuf.Timestamp updated_at = 10;
   */
  updatedAt?: Timestamp;

  /**
   * RosterTypeName is the unique name of the roster type.
   *
   * @generated from field: string roster_type_name = 11;
   */
  rosterTypeName: string;

  /**
   * CASIndex is used to ensure atomic updates to rosters.
   *
   * @generated from field: uint64 cas_index = 12;
   */
  casIndex: bigint;
};

/**
 * Describes the message tkd.roster.v1.Roster.
 * Use `create(RosterSchema)` to create a new message.
 */
export declare const RosterSchema: GenMessage<Roster>;

/**
 * @generated from message tkd.roster.v1.SaveRosterRequest
 */
export declare type SaveRosterRequest = Message<"tkd.roster.v1.SaveRosterRequest"> & {
  /**
   * ID is the unique ID of the roster. If the roster is created for the first
   * time this field may be empty. Subsequent SaveRosterRequests should populate
   * the ID returned in the response of the first SaveRosterRequest.
   *
   * @generated from field: string id = 1;
   */
  id: string;

  /**
   * From holds the date of the first day in the roster.
   * It should follow the format YYYY-MM-DD as in 2006-01-02.
   * Note that chaning the from-time after the roster has been
   * initialy created is not allowed.
   *
   * @generated from field: string from = 2;
   */
  from: string;

  /**
   * To holds the date of the lalst day in the roster.
   * It should follow the format YYYY-MM-DD as in 2006-01-02.
   * Note that chaning the to-time after the roster has been
   * initialy created is not allowed.
   *
   * @generated from field: string to = 3;
   */
  to: string;

  /**
   * Shifts is a list of planned roster shifts.
   *
   * @generated from field: repeated tkd.roster.v1.PlannedShift shifts = 4;
   */
  shifts: PlannedShift[];

  /**
   * ReadMask may be used to limit the response of the SaveRosterRequest.
   *
   * @generated from field: google.protobuf.FieldMask read_mask = 5;
   */
  readMask?: FieldMask;

  /**
   * See Roster.shift_tags.
   * This field must not be changed once saved.
   *
   * @generated from field: repeated string shift_tags = 7;
   */
  shiftTags: string[];

  /**
   * RosterTypeName is the unique name of the roster type.
   *
   * @generated from field: string roster_type_name = 8;
   */
  rosterTypeName: string;

  /**
   * TimeTrackingOnly can be set to true to include work time analysis only for
   * work-time entries with time-tracking enabled.
   *
   * @generated from field: bool time_tracking_only = 9;
   */
  timeTrackingOnly: boolean;

  /**
   * CASIndex can be set to the CASIndex returned by GetRoster to ensure
   * there have been no changes.
   *
   * @generated from field: uint64 cas_index = 10;
   */
  casIndex: bigint;
};

/**
 * Describes the message tkd.roster.v1.SaveRosterRequest.
 * Use `create(SaveRosterRequestSchema)` to create a new message.
 */
export declare const SaveRosterRequestSchema: GenMessage<SaveRosterRequest>;

/**
 * @generated from message tkd.roster.v1.WorkTimeAnalysisWeek
 */
export declare type WorkTimeAnalysisWeek = Message<"tkd.roster.v1.WorkTimeAnalysisWeek"> & {
  /**
   * @generated from field: int32 year = 1;
   */
  year: number;

  /**
   * @generated from field: int32 week = 2;
   */
  week: number;

  /**
   * @generated from field: int32 working_days = 3;
   */
  workingDays: number;

  /**
   * @generated from field: google.protobuf.Duration expected_work = 4;
   */
  expectedWork?: Duration;

  /**
   * @generated from field: google.protobuf.Duration planned = 5;
   */
  planned?: Duration;
};

/**
 * Describes the message tkd.roster.v1.WorkTimeAnalysisWeek.
 * Use `create(WorkTimeAnalysisWeekSchema)` to create a new message.
 */
export declare const WorkTimeAnalysisWeekSchema: GenMessage<WorkTimeAnalysisWeek>;

/**
 * @generated from message tkd.roster.v1.WorkTimeAnalysisStep
 */
export declare type WorkTimeAnalysisStep = Message<"tkd.roster.v1.WorkTimeAnalysisStep"> & {
  /**
   * @generated from field: string work_time_id = 1;
   */
  workTimeId: string;

  /**
   * @generated from field: repeated tkd.roster.v1.WorkTimeAnalysisWeek weeks = 2;
   */
  weeks: WorkTimeAnalysisWeek[];

  /**
   * @generated from field: google.protobuf.Duration expected_work_time = 3;
   */
  expectedWorkTime?: Duration;

  /**
   * @generated from field: google.protobuf.Duration work_time_per_week = 4;
   */
  workTimePerWeek?: Duration;

  /**
   * YYYY-MM-DD
   *
   * @generated from field: string from = 5;
   */
  from: string;

  /**
   * YYYY-MM-DD
   *
   * @generated from field: string to = 6;
   */
  to: string;

  /**
   * @generated from field: google.protobuf.Duration planned = 7;
   */
  planned?: Duration;

  /**
   * Overtime holds the overtime of the user taking overtime allowance per month
   * into consideration.
   *
   * @generated from field: google.protobuf.Duration overtime = 8;
   */
  overtime?: Duration;
};

/**
 * Describes the message tkd.roster.v1.WorkTimeAnalysisStep.
 * Use `create(WorkTimeAnalysisStepSchema)` to create a new message.
 */
export declare const WorkTimeAnalysisStepSchema: GenMessage<WorkTimeAnalysisStep>;

/**
 * @generated from message tkd.roster.v1.WorkTimeAnalysis
 */
export declare type WorkTimeAnalysis = Message<"tkd.roster.v1.WorkTimeAnalysis"> & {
  /**
   * UserId is the ID of the user this WorkTimeAnalysis belongs to.
   *
   * @generated from field: string user_id = 1;
   */
  userId: string;

  /**
   * PlannedTime is the actual working time that is planned for the
   * user.
   *
   * @generated from field: google.protobuf.Duration planned_time = 2;
   */
  plannedTime?: Duration;

  /**
   * ExpectedTime holds the work-time that the user is expected to
   * deliver.
   *
   * @generated from field: google.protobuf.Duration expected_time = 3;
   */
  expectedTime?: Duration;

  /**
   * @generated from field: repeated tkd.roster.v1.WorkTimeAnalysisStep steps = 4;
   */
  steps: WorkTimeAnalysisStep[];

  /**
   * Overtime holds the overtime of the user taking overtime allowance per month
   * into consideration.
   *
   * @generated from field: google.protobuf.Duration overtime = 5;
   */
  overtime?: Duration;

  /**
   * Whether or not this user should be excluded from time-tracking.
   *
   * @generated from field: bool exclude_from_time_tracking = 6;
   */
  excludeFromTimeTracking: boolean;

  /**
   * An date after which there's no work-time for the user.
   * Format: YYYY-MM-DD
   *
   * @generated from field: string ends_with = 7;
   */
  endsWith: string;
};

/**
 * Describes the message tkd.roster.v1.WorkTimeAnalysis.
 * Use `create(WorkTimeAnalysisSchema)` to create a new message.
 */
export declare const WorkTimeAnalysisSchema: GenMessage<WorkTimeAnalysis>;

/**
 * @generated from message tkd.roster.v1.SaveRosterResponse
 */
export declare type SaveRosterResponse = Message<"tkd.roster.v1.SaveRosterResponse"> & {
  /**
   * Roster is the final saved roster.
   * Use read_mask in SaveRosterRequest if you don't need
   * to retrieve the full roster after saving a change.
   *
   * @generated from field: tkd.roster.v1.Roster roster = 1;
   */
  roster?: Roster;

  /**
   * WorkTimeAnalysis holds work-time statistics for each user
   * that has a WorkTime set.
   *
   * @generated from field: repeated tkd.roster.v1.WorkTimeAnalysis work_time_analysis = 2;
   */
  workTimeAnalysis: WorkTimeAnalysis[];
};

/**
 * Describes the message tkd.roster.v1.SaveRosterResponse.
 * Use `create(SaveRosterResponseSchema)` to create a new message.
 */
export declare const SaveRosterResponseSchema: GenMessage<SaveRosterResponse>;

/**
 * @generated from message tkd.roster.v1.UsersToAnalyze
 */
export declare type UsersToAnalyze = Message<"tkd.roster.v1.UsersToAnalyze"> & {
  /**
   * UserIds is a list of users to analyze.
   *
   * @generated from field: repeated string user_ids = 1;
   */
  userIds: string[];

  /**
   * AllUsers may be set to true if all users that have a work-time specified
   * should be included in analysis.
   *
   * @generated from field: bool all_users = 2;
   */
  allUsers: boolean;
};

/**
 * Describes the message tkd.roster.v1.UsersToAnalyze.
 * Use `create(UsersToAnalyzeSchema)` to create a new message.
 */
export declare const UsersToAnalyzeSchema: GenMessage<UsersToAnalyze>;

/**
 * @generated from message tkd.roster.v1.AnalyzeWorkTimeRequest
 */
export declare type AnalyzeWorkTimeRequest = Message<"tkd.roster.v1.AnalyzeWorkTimeRequest"> & {
  /**
   * Users specifies which users should be analyzed. If unset (i.e. a nil message) than
   * only the user that performs the request will be analyzed.
   * Note that the role roster_manager is required when this field is set.
   *
   * @generated from field: tkd.roster.v1.UsersToAnalyze users = 1;
   */
  users?: UsersToAnalyze;

  /**
   * From holds the date (format YYYY-MM-DD; ie. 2006-01-02) of the first day to include in analysis.
   * Not that if a work-shift begins the day before but spans into the date specified here it will
   * NOT be included in analysis.
   *
   * @generated from field: string from = 3;
   */
  from: string;

  /**
   * To holds teh date (format YYYY-MM-DD; ie. 2006-01-02) of the last day to include in analysis.
   * Note that if a work-shift begins at the specified date but spans to the next date it will still
   * be included as a whole in the analysis.
   *
   * @generated from field: string to = 4;
   */
  to: string;

  /**
   * TimeTrackingOnly may be set to true to only incude work-times for which time-tracking is
   * enabled.
   *
   * @generated from field: bool time_tracking_only = 5;
   */
  timeTrackingOnly: boolean;
};

/**
 * Describes the message tkd.roster.v1.AnalyzeWorkTimeRequest.
 * Use `create(AnalyzeWorkTimeRequestSchema)` to create a new message.
 */
export declare const AnalyzeWorkTimeRequestSchema: GenMessage<AnalyzeWorkTimeRequest>;

/**
 * @generated from message tkd.roster.v1.AnalyzeWorkTimeResponse
 */
export declare type AnalyzeWorkTimeResponse = Message<"tkd.roster.v1.AnalyzeWorkTimeResponse"> & {
  /**
   * @generated from field: repeated tkd.roster.v1.WorkTimeAnalysis results = 1;
   */
  results: WorkTimeAnalysis[];
};

/**
 * Describes the message tkd.roster.v1.AnalyzeWorkTimeResponse.
 * Use `create(AnalyzeWorkTimeResponseSchema)` to create a new message.
 */
export declare const AnalyzeWorkTimeResponseSchema: GenMessage<AnalyzeWorkTimeResponse>;

/**
 * @generated from message tkd.roster.v1.ApproveRosterWorkTimeSplit
 */
export declare type ApproveRosterWorkTimeSplit = Message<"tkd.roster.v1.ApproveRosterWorkTimeSplit"> & {
  /**
   * @generated from field: string user_id = 1;
   */
  userId: string;

  /**
   * @generated from field: google.protobuf.Duration time_off = 2;
   */
  timeOff?: Duration;

  /**
   * @generated from field: google.protobuf.Duration vacation = 3;
   */
  vacation?: Duration;
};

/**
 * Describes the message tkd.roster.v1.ApproveRosterWorkTimeSplit.
 * Use `create(ApproveRosterWorkTimeSplitSchema)` to create a new message.
 */
export declare const ApproveRosterWorkTimeSplitSchema: GenMessage<ApproveRosterWorkTimeSplit>;

/**
 * @generated from message tkd.roster.v1.ApproveRosterRequest
 */
export declare type ApproveRosterRequest = Message<"tkd.roster.v1.ApproveRosterRequest"> & {
  /**
   * @generated from field: string id = 1;
   */
  id: string;

  /**
   * @generated from field: map<string, tkd.roster.v1.ApproveRosterWorkTimeSplit> work_time_split = 2;
   */
  workTimeSplit: { [key: string]: ApproveRosterWorkTimeSplit };

  /**
   * @generated from field: repeated string send_notification_to_users = 3;
   */
  sendNotificationToUsers: string[];
};

/**
 * Describes the message tkd.roster.v1.ApproveRosterRequest.
 * Use `create(ApproveRosterRequestSchema)` to create a new message.
 */
export declare const ApproveRosterRequestSchema: GenMessage<ApproveRosterRequest>;

/**
 * @generated from message tkd.roster.v1.ApproveRosterResponse
 */
export declare type ApproveRosterResponse = Message<"tkd.roster.v1.ApproveRosterResponse"> & {
};

/**
 * Describes the message tkd.roster.v1.ApproveRosterResponse.
 * Use `create(ApproveRosterResponseSchema)` to create a new message.
 */
export declare const ApproveRosterResponseSchema: GenMessage<ApproveRosterResponse>;

/**
 * @generated from message tkd.roster.v1.DeleteRosterRequest
 */
export declare type DeleteRosterRequest = Message<"tkd.roster.v1.DeleteRosterRequest"> & {
  /**
   * @generated from field: string id = 1;
   */
  id: string;
};

/**
 * Describes the message tkd.roster.v1.DeleteRosterRequest.
 * Use `create(DeleteRosterRequestSchema)` to create a new message.
 */
export declare const DeleteRosterRequestSchema: GenMessage<DeleteRosterRequest>;

/**
 * @generated from message tkd.roster.v1.DeleteRosterResponse
 */
export declare type DeleteRosterResponse = Message<"tkd.roster.v1.DeleteRosterResponse"> & {
};

/**
 * Describes the message tkd.roster.v1.DeleteRosterResponse.
 * Use `create(DeleteRosterResponseSchema)` to create a new message.
 */
export declare const DeleteRosterResponseSchema: GenMessage<DeleteRosterResponse>;

/**
 * @generated from message tkd.roster.v1.GetRosterRequest
 */
export declare type GetRosterRequest = Message<"tkd.roster.v1.GetRosterRequest"> & {
  /**
   * @generated from oneof tkd.roster.v1.GetRosterRequest.search
   */
  search: {
    /**
     * @generated from field: string id = 1;
     */
    value: string;
    case: "id";
  } | {
    /**
     * Deprecated: use date_string instead
     *
     * @generated from field: google.protobuf.Timestamp date = 2;
     */
    value: Timestamp;
    case: "date";
  } | {
    /**
     * Format: YYYY-MM-DD
     *
     * @generated from field: string date_string = 6;
     */
    value: string;
    case: "dateString";
  } | { case: undefined; value?: undefined };

  /**
   * @generated from field: repeated string roster_type_names = 3;
   */
  rosterTypeNames: string[];

  /**
   * @generated from field: google.protobuf.FieldMask read_mask = 4;
   */
  readMask?: FieldMask;

  /**
   * TimeTrackingOnly may be set to true to only incude work-times for which time-tracking is
   * enabled.
   *
   * @generated from field: bool time_tracking_only = 5;
   */
  timeTrackingOnly: boolean;
};

/**
 * Describes the message tkd.roster.v1.GetRosterRequest.
 * Use `create(GetRosterRequestSchema)` to create a new message.
 */
export declare const GetRosterRequestSchema: GenMessage<GetRosterRequest>;

/**
 * @generated from message tkd.roster.v1.GetRosterResponse
 */
export declare type GetRosterResponse = Message<"tkd.roster.v1.GetRosterResponse"> & {
  /**
   * @generated from field: repeated tkd.roster.v1.Roster roster = 1;
   */
  roster: Roster[];

  /**
   * @generated from field: repeated tkd.roster.v1.WorkTimeAnalysis work_time_analysis = 2;
   */
  workTimeAnalysis: WorkTimeAnalysis[];
};

/**
 * Describes the message tkd.roster.v1.GetRosterResponse.
 * Use `create(GetRosterResponseSchema)` to create a new message.
 */
export declare const GetRosterResponseSchema: GenMessage<GetRosterResponse>;

/**
 * @generated from message tkd.roster.v1.GetWorkingStaffRequest
 */
export declare type GetWorkingStaffRequest = Message<"tkd.roster.v1.GetWorkingStaffRequest"> & {
  /**
   * @generated from field: google.protobuf.Timestamp time = 1;
   */
  time?: Timestamp;

  /**
   * @generated from field: google.protobuf.FieldMask read_maks = 2;
   */
  readMaks?: FieldMask;

  /**
   * RosterTypeName may be set to the name of the roster type
   * to limit which working-shifts are considered for the response.
   *
   * @generated from field: string roster_type_name = 3;
   */
  rosterTypeName: string;

  /**
   * OnCall may be set to true to limit the response to only include
   * working staff IDs assigned to on-call shifts. 
   *
   * @generated from field: bool on_call = 4;
   */
  onCall: boolean;
};

/**
 * Describes the message tkd.roster.v1.GetWorkingStaffRequest.
 * Use `create(GetWorkingStaffRequestSchema)` to create a new message.
 */
export declare const GetWorkingStaffRequestSchema: GenMessage<GetWorkingStaffRequest>;

/**
 * @generated from message tkd.roster.v1.GetWorkingStaffRequest2
 */
export declare type GetWorkingStaffRequest2 = Message<"tkd.roster.v1.GetWorkingStaffRequest2"> & {
  /**
   * @generated from oneof tkd.roster.v1.GetWorkingStaffRequest2.query
   */
  query: {
    /**
     * @generated from field: google.protobuf.Timestamp time = 1;
     */
    value: Timestamp;
    case: "time";
  } | {
    /**
     * @generated from field: tkd.common.v1.TimeRange time_range = 2;
     */
    value: TimeRange;
    case: "timeRange";
  } | { case: undefined; value?: undefined };

  /**
   * @generated from field: google.protobuf.FieldMask read_maks = 5;
   */
  readMaks?: FieldMask;

  /**
   * RosterTypeName may be set to the name of the roster type
   * to limit which working-shifts are considered for the response.
   *
   * @generated from field: string roster_type_name = 6;
   */
  rosterTypeName: string;

  /**
   * OnCall may be set to true to limit the response to only include
   * working staff IDs assigned to on-call shifts. 
   *
   * @generated from field: bool on_call = 7;
   */
  onCall: boolean;

  /**
   * ShiftTags is a list of shift-tags that should be considered.
   *
   * @generated from field: repeated string shift_tags = 8;
   */
  shiftTags: string[];
};

/**
 * Describes the message tkd.roster.v1.GetWorkingStaffRequest2.
 * Use `create(GetWorkingStaffRequest2Schema)` to create a new message.
 */
export declare const GetWorkingStaffRequest2Schema: GenMessage<GetWorkingStaffRequest2>;

/**
 * @generated from message tkd.roster.v1.GetWorkingStaffResponse
 */
export declare type GetWorkingStaffResponse = Message<"tkd.roster.v1.GetWorkingStaffResponse"> & {
  /**
   * @generated from field: repeated string user_ids = 1;
   */
  userIds: string[];

  /**
   * @generated from field: repeated tkd.roster.v1.PlannedShift current_shifts = 2;
   */
  currentShifts: PlannedShift[];

  /**
   * @generated from field: repeated string roster_id = 3;
   */
  rosterId: string[];
};

/**
 * Describes the message tkd.roster.v1.GetWorkingStaffResponse.
 * Use `create(GetWorkingStaffResponseSchema)` to create a new message.
 */
export declare const GetWorkingStaffResponseSchema: GenMessage<GetWorkingStaffResponse>;

/**
 * @generated from message tkd.roster.v1.GetRequiredShiftsRequest
 */
export declare type GetRequiredShiftsRequest = Message<"tkd.roster.v1.GetRequiredShiftsRequest"> & {
  /**
   * From holds the date (format YYYY-MM-DD; ie. 2006-01-02) of the first day to include.
   *
   * @generated from field: string from = 1;
   */
  from: string;

  /**
   * To holds teh date (format YYYY-MM-DD; ie. 2006-01-02) of the last day to include.
   *
   * @generated from field: string to = 2;
   */
  to: string;

  /**
   * RosterTypeName is the name of the roster type for which shifts should be loaded.
   *
   * @generated from field: string roster_type_name = 3;
   */
  rosterTypeName: string;

  /**
   * ReadMask may be use to limit which fields should be included in the response.
   *
   * @generated from field: google.protobuf.FieldMask read_mask = 4;
   */
  readMask?: FieldMask;

  /**
   * Only return shifts that match the roster_type on_call_tags.
   *
   * @generated from field: bool on_call = 5;
   */
  onCall: boolean;
};

/**
 * Describes the message tkd.roster.v1.GetRequiredShiftsRequest.
 * Use `create(GetRequiredShiftsRequestSchema)` to create a new message.
 */
export declare const GetRequiredShiftsRequestSchema: GenMessage<GetRequiredShiftsRequest>;

/**
 * @generated from message tkd.roster.v1.GetRequiredShiftsResponse
 */
export declare type GetRequiredShiftsResponse = Message<"tkd.roster.v1.GetRequiredShiftsResponse"> & {
  /**
   * RequiredShifts holds a list of shifts that must be configured for a valid roster.
   *
   * @generated from field: repeated tkd.roster.v1.RequiredShift required_shifts = 1;
   */
  requiredShifts: RequiredShift[];

  /**
   * WorkShiftDefinitions (if requested by GetRequiredShiftsRequest.read_mask; default: yes)
   * is set to a list of WorkShift definitions that are referenced by GetRequiredShiftsResponse.required_shifts.work_shift_id;
   *
   * @generated from field: repeated tkd.roster.v1.WorkShift work_shift_definitions = 2;
   */
  workShiftDefinitions: WorkShift[];

  /**
   * WorkDays is a list of days and wether they are counted as work days or not.
   *
   * @generated from field: repeated tkd.roster.v1.Day days = 3;
   */
  days: Day[];
};

/**
 * Describes the message tkd.roster.v1.GetRequiredShiftsResponse.
 * Use `create(GetRequiredShiftsResponseSchema)` to create a new message.
 */
export declare const GetRequiredShiftsResponseSchema: GenMessage<GetRequiredShiftsResponse>;

/**
 * @generated from message tkd.roster.v1.Day
 */
export declare type Day = Message<"tkd.roster.v1.Day"> & {
  /**
   * Date is the date of the day in format YYYY-MM-DD.
   *
   * @generated from field: string date = 1;
   */
  date: string;

  /**
   * Type is the type of the day.
   *
   * @generated from field: tkd.roster.v1.DayType type = 2;
   */
  type: DayType;
};

/**
 * Describes the message tkd.roster.v1.Day.
 * Use `create(DaySchema)` to create a new message.
 */
export declare const DaySchema: GenMessage<Day>;

/**
 * @generated from message tkd.roster.v1.SendRosterPreviewRequest
 */
export declare type SendRosterPreviewRequest = Message<"tkd.roster.v1.SendRosterPreviewRequest"> & {
  /**
   * @generated from field: string id = 1;
   */
  id: string;

  /**
   * @generated from field: repeated string send_notification_to_users = 2;
   */
  sendNotificationToUsers: string[];
};

/**
 * Describes the message tkd.roster.v1.SendRosterPreviewRequest.
 * Use `create(SendRosterPreviewRequestSchema)` to create a new message.
 */
export declare const SendRosterPreviewRequestSchema: GenMessage<SendRosterPreviewRequest>;

/**
 * @generated from message tkd.roster.v1.SendRosterPreviewResponse
 */
export declare type SendRosterPreviewResponse = Message<"tkd.roster.v1.SendRosterPreviewResponse"> & {
  /**
   * @generated from field: repeated tkd.idm.v1.DeliveryNotification delivery = 1;
   */
  delivery: DeliveryNotification[];
};

/**
 * Describes the message tkd.roster.v1.SendRosterPreviewResponse.
 * Use `create(SendRosterPreviewResponseSchema)` to create a new message.
 */
export declare const SendRosterPreviewResponseSchema: GenMessage<SendRosterPreviewResponse>;

/**
 * @generated from message tkd.roster.v1.CreateRosterTypeRequest
 */
export declare type CreateRosterTypeRequest = Message<"tkd.roster.v1.CreateRosterTypeRequest"> & {
  /**
   * @generated from field: tkd.roster.v1.RosterType roster_type = 1;
   */
  rosterType?: RosterType;
};

/**
 * Describes the message tkd.roster.v1.CreateRosterTypeRequest.
 * Use `create(CreateRosterTypeRequestSchema)` to create a new message.
 */
export declare const CreateRosterTypeRequestSchema: GenMessage<CreateRosterTypeRequest>;

/**
 * @generated from message tkd.roster.v1.CreateRosterTypeResponse
 */
export declare type CreateRosterTypeResponse = Message<"tkd.roster.v1.CreateRosterTypeResponse"> & {
  /**
   * @generated from field: tkd.roster.v1.RosterType roster_type = 1;
   */
  rosterType?: RosterType;
};

/**
 * Describes the message tkd.roster.v1.CreateRosterTypeResponse.
 * Use `create(CreateRosterTypeResponseSchema)` to create a new message.
 */
export declare const CreateRosterTypeResponseSchema: GenMessage<CreateRosterTypeResponse>;

/**
 * @generated from message tkd.roster.v1.DeleteRosterTypeRequest
 */
export declare type DeleteRosterTypeRequest = Message<"tkd.roster.v1.DeleteRosterTypeRequest"> & {
  /**
   * @generated from field: string unique_name = 1;
   */
  uniqueName: string;
};

/**
 * Describes the message tkd.roster.v1.DeleteRosterTypeRequest.
 * Use `create(DeleteRosterTypeRequestSchema)` to create a new message.
 */
export declare const DeleteRosterTypeRequestSchema: GenMessage<DeleteRosterTypeRequest>;

/**
 * @generated from message tkd.roster.v1.DeleteRosterTypeResponse
 */
export declare type DeleteRosterTypeResponse = Message<"tkd.roster.v1.DeleteRosterTypeResponse"> & {
};

/**
 * Describes the message tkd.roster.v1.DeleteRosterTypeResponse.
 * Use `create(DeleteRosterTypeResponseSchema)` to create a new message.
 */
export declare const DeleteRosterTypeResponseSchema: GenMessage<DeleteRosterTypeResponse>;

/**
 * @generated from message tkd.roster.v1.ListRosterTypesRequest
 */
export declare type ListRosterTypesRequest = Message<"tkd.roster.v1.ListRosterTypesRequest"> & {
};

/**
 * Describes the message tkd.roster.v1.ListRosterTypesRequest.
 * Use `create(ListRosterTypesRequestSchema)` to create a new message.
 */
export declare const ListRosterTypesRequestSchema: GenMessage<ListRosterTypesRequest>;

/**
 * @generated from message tkd.roster.v1.ListRosterTypesResponse
 */
export declare type ListRosterTypesResponse = Message<"tkd.roster.v1.ListRosterTypesResponse"> & {
  /**
   * @generated from field: repeated tkd.roster.v1.RosterType roster_types = 1;
   */
  rosterTypes: RosterType[];
};

/**
 * Describes the message tkd.roster.v1.ListRosterTypesResponse.
 * Use `create(ListRosterTypesResponseSchema)` to create a new message.
 */
export declare const ListRosterTypesResponseSchema: GenMessage<ListRosterTypesResponse>;

/**
 * @generated from message tkd.roster.v1.ListShiftTagsRequest
 */
export declare type ListShiftTagsRequest = Message<"tkd.roster.v1.ListShiftTagsRequest"> & {
};

/**
 * Describes the message tkd.roster.v1.ListShiftTagsRequest.
 * Use `create(ListShiftTagsRequestSchema)` to create a new message.
 */
export declare const ListShiftTagsRequestSchema: GenMessage<ListShiftTagsRequest>;

/**
 * @generated from message tkd.roster.v1.ListShiftTagsResponse
 */
export declare type ListShiftTagsResponse = Message<"tkd.roster.v1.ListShiftTagsResponse"> & {
  /**
   * @generated from field: repeated string tags = 1;
   */
  tags: string[];
};

/**
 * Describes the message tkd.roster.v1.ListShiftTagsResponse.
 * Use `create(ListShiftTagsResponseSchema)` to create a new message.
 */
export declare const ListShiftTagsResponseSchema: GenMessage<ListShiftTagsResponse>;

/**
 * @generated from message tkd.roster.v1.GetUserShiftsRequest
 */
export declare type GetUserShiftsRequest = Message<"tkd.roster.v1.GetUserShiftsRequest"> & {
  /**
   * @generated from field: tkd.common.v1.TimeRange timerange = 1;
   */
  timerange?: TimeRange;

  /**
   * if empty, only the working shifts for the authenticated
   * user are returned
   *
   * @generated from field: tkd.roster.v1.UsersToAnalyze users = 2;
   */
  users?: UsersToAnalyze;
};

/**
 * Describes the message tkd.roster.v1.GetUserShiftsRequest.
 * Use `create(GetUserShiftsRequestSchema)` to create a new message.
 */
export declare const GetUserShiftsRequestSchema: GenMessage<GetUserShiftsRequest>;

/**
 * @generated from message tkd.roster.v1.GetUserShiftsResponse
 */
export declare type GetUserShiftsResponse = Message<"tkd.roster.v1.GetUserShiftsResponse"> & {
  /**
   * @generated from field: repeated tkd.roster.v1.PlannedShift shifts = 1;
   */
  shifts: PlannedShift[];

  /**
   * @generated from field: repeated tkd.roster.v1.WorkShift definitions = 2;
   */
  definitions: WorkShift[];
};

/**
 * Describes the message tkd.roster.v1.GetUserShiftsResponse.
 * Use `create(GetUserShiftsResponseSchema)` to create a new message.
 */
export declare const GetUserShiftsResponseSchema: GenMessage<GetUserShiftsResponse>;

/**
 * @generated from message tkd.roster.v1.ExportRosterRequest
 */
export declare type ExportRosterRequest = Message<"tkd.roster.v1.ExportRosterRequest"> & {
  /**
   * @generated from field: string id = 1;
   */
  id: string;

  /**
   * @generated from field: tkd.roster.v1.ExportRosterType type = 2;
   */
  type: ExportRosterType;

  /**
   * @generated from oneof tkd.roster.v1.ExportRosterRequest.filter
   */
  filter: {
    /**
     * @generated from field: tkd.roster.v1.StringList shift_tags = 3;
     */
    value: StringList;
    case: "shiftTags";
  } | {
    /**
     * @generated from field: tkd.roster.v1.StringList shift_ids = 4;
     */
    value: StringList;
    case: "shiftIds";
  } | { case: undefined; value?: undefined };
};

/**
 * Describes the message tkd.roster.v1.ExportRosterRequest.
 * Use `create(ExportRosterRequestSchema)` to create a new message.
 */
export declare const ExportRosterRequestSchema: GenMessage<ExportRosterRequest>;

/**
 * @generated from message tkd.roster.v1.ExportRosterResponse
 */
export declare type ExportRosterResponse = Message<"tkd.roster.v1.ExportRosterResponse"> & {
  /**
   * @generated from field: string content_type = 2;
   */
  contentType: string;

  /**
   * @generated from field: string file_name = 1;
   */
  fileName: string;

  /**
   * @generated from field: bytes payload = 3;
   */
  payload: Uint8Array;
};

/**
 * Describes the message tkd.roster.v1.ExportRosterResponse.
 * Use `create(ExportRosterResponseSchema)` to create a new message.
 */
export declare const ExportRosterResponseSchema: GenMessage<ExportRosterResponse>;

/**
 * TODO(ppacher): move to common?
 *
 * @generated from message tkd.roster.v1.StringList
 */
export declare type StringList = Message<"tkd.roster.v1.StringList"> & {
  /**
   * @generated from field: repeated string values = 1;
   */
  values: string[];
};

/**
 * Describes the message tkd.roster.v1.StringList.
 * Use `create(StringListSchema)` to create a new message.
 */
export declare const StringListSchema: GenMessage<StringList>;

/**
 * @generated from enum tkd.roster.v1.DayType
 */
export enum DayType {
  /**
   * @generated from enum value: DAY_TYPE_UNSPECIFIED = 0;
   */
  UNSPECIFIED = 0,

  /**
   * @generated from enum value: DAY_TYPE_WORKDAY = 1;
   */
  WORKDAY = 1,

  /**
   * @generated from enum value: DAY_TYPE_WEEKEND = 2;
   */
  WEEKEND = 2,

  /**
   * @generated from enum value: DAY_TYPE_HOLIDAY = 3;
   */
  HOLIDAY = 3,
}

/**
 * Describes the enum tkd.roster.v1.DayType.
 */
export declare const DayTypeSchema: GenEnum<DayType>;

/**
 * @generated from enum tkd.roster.v1.ExportRosterType
 */
export enum ExportRosterType {
  /**
   * @generated from enum value: EXPORT_ROSTER_TYPE_UNSPECIFIED = 0;
   */
  UNSPECIFIED = 0,

  /**
   * @generated from enum value: EXPORT_ROSTER_TYPE_PDF = 1;
   */
  PDF = 1,

  /**
   * @generated from enum value: EXPORT_ROSTER_TYPE_ICAL = 2;
   */
  ICAL = 2,

  /**
   * @generated from enum value: EXPORT_ROSTER_TYPE_HTML = 3;
   */
  HTML = 3,
}

/**
 * Describes the enum tkd.roster.v1.ExportRosterType.
 */
export declare const ExportRosterTypeSchema: GenEnum<ExportRosterType>;

/**
 * @generated from service tkd.roster.v1.RosterService
 */
export declare const RosterService: GenService<{
  /**
   * @generated from rpc tkd.roster.v1.RosterService.CreateRosterType
   */
  createRosterType: {
    methodKind: "unary";
    input: typeof CreateRosterTypeRequestSchema;
    output: typeof CreateRosterTypeResponseSchema;
  },
  /**
   * @generated from rpc tkd.roster.v1.RosterService.DeleteRosterType
   */
  deleteRosterType: {
    methodKind: "unary";
    input: typeof DeleteRosterTypeRequestSchema;
    output: typeof DeleteRosterTypeResponseSchema;
  },
  /**
   * @generated from rpc tkd.roster.v1.RosterService.ListRosterTypes
   */
  listRosterTypes: {
    methodKind: "unary";
    input: typeof ListRosterTypesRequestSchema;
    output: typeof ListRosterTypesResponseSchema;
  },
  /**
   * @generated from rpc tkd.roster.v1.RosterService.ListShiftTags
   */
  listShiftTags: {
    methodKind: "unary";
    input: typeof ListShiftTagsRequestSchema;
    output: typeof ListShiftTagsResponseSchema;
  },
  /**
   * SaveRoster saves a duty roster. It may be used to initially create a new
   * roster or to save subsequent changes.
   *
   * @generated from rpc tkd.roster.v1.RosterService.SaveRoster
   */
  saveRoster: {
    methodKind: "unary";
    input: typeof SaveRosterRequestSchema;
    output: typeof SaveRosterResponseSchema;
  },
  /**
   * @generated from rpc tkd.roster.v1.RosterService.ExportRoster
   */
  exportRoster: {
    methodKind: "unary";
    input: typeof ExportRosterRequestSchema;
    output: typeof ExportRosterResponseSchema;
  },
  /**
   * DeleteRoster deletes a roster from the internal storage. This operation
   * cannot be undone!
   *
   * @generated from rpc tkd.roster.v1.RosterService.DeleteRoster
   */
  deleteRoster: {
    methodKind: "unary";
    input: typeof DeleteRosterRequestSchema;
    output: typeof DeleteRosterResponseSchema;
  },
  /**
   * AnalyzeWorkTime can be used to analyze the work time of users to determine
   * undertime or overtime in a given time-range.
   *
   * @generated from rpc tkd.roster.v1.RosterService.AnalyzeWorkTime
   */
  analyzeWorkTime: {
    methodKind: "unary";
    input: typeof AnalyzeWorkTimeRequestSchema;
    output: typeof AnalyzeWorkTimeResponseSchema;
  },
  /**
   * ApproveRoster marks a roster as approved by management.
   *
   * @generated from rpc tkd.roster.v1.RosterService.ApproveRoster
   */
  approveRoster: {
    methodKind: "unary";
    input: typeof ApproveRosterRequestSchema;
    output: typeof ApproveRosterResponseSchema;
  },
  /**
   * GetRoster returns a previously saved roster.
   *
   * @generated from rpc tkd.roster.v1.RosterService.GetRoster
   */
  getRoster: {
    methodKind: "unary";
    input: typeof GetRosterRequestSchema;
    output: typeof GetRosterResponseSchema;
  },
  /**
   * GetWorkingStaff returns a list of user_ids that are working at the
   * date specified in GetWorkingStaffRequest. If date is unset, it defaults
   * to NOW.
   *
   * @generated from rpc tkd.roster.v1.RosterService.GetWorkingStaff
   */
  getWorkingStaff: {
    methodKind: "unary";
    input: typeof GetWorkingStaffRequestSchema;
    output: typeof GetWorkingStaffResponseSchema;
  },
  /**
   * GetWorkingStaff2 returns a list of user_ids that are working at the
   * date specified in GetWorkingStaffRequest. If date is unset, it defaults
   * to NOW.
   *
   * @generated from rpc tkd.roster.v1.RosterService.GetWorkingStaff2
   */
  getWorkingStaff2: {
    methodKind: "unary";
    input: typeof GetWorkingStaffRequest2Schema;
    output: typeof GetWorkingStaffResponseSchema;
  },
  /**
   * GetRequiredShifts returns a list of work-shifts that are required for the requested
   * time frame.
   *
   * @generated from rpc tkd.roster.v1.RosterService.GetRequiredShifts
   */
  getRequiredShifts: {
    methodKind: "unary";
    input: typeof GetRequiredShiftsRequestSchema;
    output: typeof GetRequiredShiftsResponseSchema;
  },
  /**
   * SendRosterPreview sends a preview of the specified roster by mail to all employees that are
   * assigned to at least one shift.
   *
   * @generated from rpc tkd.roster.v1.RosterService.SendRosterPreview
   */
  sendRosterPreview: {
    methodKind: "unary";
    input: typeof SendRosterPreviewRequestSchema;
    output: typeof SendRosterPreviewResponseSchema;
  },
  /**
   * GetUserShifts returns all shifts for the requesting user within the specified
   * time frame.
   *
   * @generated from rpc tkd.roster.v1.RosterService.GetUserShifts
   */
  getUserShifts: {
    methodKind: "unary";
    input: typeof GetUserShiftsRequestSchema;
    output: typeof GetUserShiftsResponseSchema;
  },
}>;

